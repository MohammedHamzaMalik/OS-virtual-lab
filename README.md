# Operating System Virtual Lab Project

## ReadMe File

### Introduction:

This Python GUI is created and designed to provide comprehensive information about what an operating system is and the various algorithms that support it.

It was created by our seniors for Disk Scheduling algorithm and Page Replacement algorithm and further we have built for CPU Scheduling algorithm.

The Python GUI front page displays all four algorithms of an operating system. The UI itself has more connections and directions. The GUI content map is as follows:

1. CPU scheduling algorithm:
- FCFS 
- SJF 
- Priority
- Round Robin
- Lottery
- Multi-Level Queue

### Guide to run the Operating System Virtual Lab:

1. Go to the GitHub repository link:

- <https://github.com/MohammedHamzaMalik/OS-virtual-lab> 

2. Click on the green drop down button labelled as ‘Code’.
3. Now click on the 'Download ZIP' to download the zip file of the full code on your system.
4. Extract the downloaded file on your desired location. 
5. Now open the extracted files in a Python IDE of your own choice.
6. After opening, run the CPUScheduling1.py file in your IDE.
7. Now you will see a new window opened which will be having title Operating System Virtual Lab.
8. On that window there will be four algorithm showed, click on the Scheduling Algorithm and work with your desired algorithm.
9. It will open up a new window with title Scheduling Algorithm Simulator.Choose your desired one and click on it.
10. It will open up a new window showing the definition of the specific algorithm and taking random inputs it will show the specific details according to it.

### CPU Scheduling Algorithm:

1. **FCFS:**

First Come First Serve is the full form of FCFS, which is the easiest and simplest CPU scheduling algorithm.

Implementation:

- Click on the “Scheduling Algorithm” button from the main window.
- Now click on the “First Come First Serve” button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of Arrival Time, Processes and Burst Time.
- The output of this will show the Completion Time, Turnaround Time, Wait Time, and Average Wait Time. 
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the CPUScheduling.py file.

2. **SJF:** 

The shortest job first (SJF) scheduling is an algorithm, which, in simple words, means that the shortest job gets executed first.

Implementation:

- Click on the “Scheduling Algorithm” button from the main window.
- Now click on the “Shortest Job First” button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of Arrival Time, Processes and Burst Time.
- The output of this will show the Completion Time, Turnaround Time, Wait Time, and Average Wait Time. 
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the CPUScheduling.py file.

3. **Priority Based Scheduling:**

Priority Scheduling is a method of scheduling processes that is based on Priority.

Implementation:

- Click on the “Scheduling Algorithm” button from the main window.
- Now click on the “Priority Based Scheduling” button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of Arrival Time, Processes and Burst Time.
- The output of this will show the Completion Time, Turnaround Time, Wait Time, and Average Wait Time. 
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the CPUScheduling.py file.

4. **Round Robin:** 

Round Robin is the oldest, simplest scheduling algorithm, which is mostly used for multitasking.

Implementation:

- Click on the “Scheduling Algorithm” button from the main window.
- Now click on the “Round Robin Scheduling” button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of Arrival Time, Processes and Burst Time.
- The output of this will show the Completion Time, Turnaround Time, Wait Time, and Average Wait Time. 
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the CPUScheduling.py file.

5. **Lottery Scheduling:**

It is a type of process scheduling, somewhat different from other Scheduling. It can be pre-emptive or non- pre-emptive.

Implementation:

- Click on the “Scheduling Algorithm” button from the main window.
- Now click on the “Lottery Scheduling” button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of Arrival Time, Processes and Burst Time.
- The output of this will show the Completion Time, Turnaround Time, Wait Time, and Average Wait Time. 
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the CPUScheduling.py file.

6. **Multi-Level Queue:**

A Multi-Level Queue scheduling algorithm partitions the ready queue into several separate queues.

Implementation:

- Click on the “Scheduling Algorithm” button from the main window.
- Now click on the “Multi-Level Queue Scheduling” button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of Arrival Time of CPU-Bound, Processes of CPU-Bound, Burst Time of CPU-Bound, Arrival Time of I/O Bound, Processes of I/O Bound, and Burst Time of I/O Bound.
- The output of this will show the Completion Time, Turnaround Time, Wait Time, and Average Wait Time of CPU-Bound processes and I/O Bound processes. 
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the CPUScheduling.py file.



### About:

- Technologies used in the project:

Python, Tkinter GUI library for Python Interface

- Code Editor:

Pycharm IDE

### Team Members:

Manav Dhami

Mohammed Hamza Malik

Priyam Seth

Priyanshu Datta

Pratham Jain

