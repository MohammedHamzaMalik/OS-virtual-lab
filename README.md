<div align="center">
  
![made-with-python](https://img.shields.io/badge/Made%20with-Python3-brightgreen)
![GitHub top language](https://img.shields.io/github/languages/top/MohammedHamzaMalik/OS-virtual-lab)
![made-with-love](https://img.shields.io/badge/Made%20with-%E2%9D%A4-ff69b4)
![GitHub repo size](https://img.shields.io/github/repo-size/MohammedHamzaMalik/OS-virtual-lab)
![Lines of code](https://img.shields.io/tokei/lines/github/MohammedHamzaMalik/OS-virtual-lab?color=lightblue)
  
</div>

<h1 align="center"> Operating System Virtual Lab Project </h1> <br>

<br /><br />

<img align="left" src="https://user-images.githubusercontent.com/65415371/124739629-f43cde80-df11-11eb-9033-c5d1d7194f03.png" width="50px" />

## Table of Contents

- #### [Introduction](#intro)
- #### [Guide to run the Operating System Virtual Lab](#guide)
- #### [CPU Scheduling Algorithm](#CPUSchedulingAlgorithm)
- #### [About](#idabout) 
- #### [Team Members](#TeamMembers)

<br /><br />

<img align="left" src="https://user-images.githubusercontent.com/65415371/124739888-2cdcb800-df12-11eb-8952-5be64764a7aa.png" width="50px" />

<h2 align="left" id="intro"> Introduction: </h2> <br>
<!-- ### Introduction: -->

This **Python GUI** is created and designed to provide comprehensive information about what an operating system is and the various algorithms that support it.

It was created by our seniors for Disk Scheduling algorithm and Page Replacement algorithm and further we have built for **CPU Scheduling algorithm**.

The Python GUI front page displays all four algorithms of an operating system. The UI itself has more connections and directions. The GUI content map is as follows:

## CPU scheduling algorithm:
- #### [FCFS](#first)
- #### [SJF](#second)
- #### [Priority Based Scheduling](#PriorityBasedScheduling)
- #### [Round Robin](#RoundRobin)
- #### [Lottery Scheduling](#LotteryScheduling)
- #### [Multi-Level Queue](#MultiLevelQueue)

<br /><br />

<img align="left" src="https://user-images.githubusercontent.com/65415371/124740742-f94e5d80-df12-11eb-8ca9-7d2ad4f56e3d.png" width="50px" />

<h2 align="left" id="guide"> Guide to run the Operating System Virtual Lab: </h2> <br>
<!-- ### Guide to run the Operating System Virtual Lab: -->

1. Go to the GitHub repository link:

- <https://github.com/MohammedHamzaMalik/OS-virtual-lab> 

2. Click on the **green drop down button** labelled as **‘Code’**.
3. Now click on the **'Download ZIP'** to download the zip file of the **full code on your system**.
4. **Extract** the downloaded file on your desired location. 
5. Now open the extracted files in a **Python IDE** of your own choice.
6. After opening, run the **CPUScheduling1.py** file in your IDE.
7. Now you will see a **new window** opened which will be having title **Operating System Virtual Lab.**
8. On that window there will be **four algorithm** showed, click on the **Scheduling Algorithm**.
9. It will open up a new window with title **Scheduling Algorithm Simulator**.Choose your desired one and click on it.
10. It will open up a new window showing **the definition** of the specific algorithm and taking **random inputs** it will show the specific details according to it.

<br /><br />

<img align="left" src="https://user-images.githubusercontent.com/65415371/124740181-74634400-df12-11eb-929c-9aa1bf060806.png" width="50px" />

<h2 align="left" id="CPUSchedulingAlgorithm"> CPU Scheduling Algorithm: </h2> <br>
<!-- ### CPU Scheduling Algorithm: -->

<h2 align="left" id="first"> 1. FCFS </h2>

**First Come First Serve is the full form of FCFS, which is the easiest and simplest CPU scheduling algorithm.**

**Implementation:**

- Click on the **“Scheduling Algorithm”** button from the main window.
- Now click on the **“First Come First Serve”** button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of **Arrival Time, Processes and Burst Time.**
- The output of this will show the **Completion Time, Turnaround Time, Wait Time, and Average Wait Time.** 
- After that there will be **two options**, either you can run another program or quit from there only.
- The code for this is available in the **CPUScheduling.py** file.

<h2 align="left" id="second"> 2. SJF </h2>

**The shortest job first (SJF) scheduling is an algorithm, which, in simple words, means that the shortest job gets executed first.**

**Implementation:**

- Click on the **“Scheduling Algorithm”** button from the main window.
- Now click on the **“Shortest Job First”** button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of **Arrival Time, Processes and Burst Time.**
- The output of this will show the **Completion Time, Turnaround Time, Wait Time, and Average Wait Time. **
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the **CPUScheduling.py** file.

<!-- ### 3. **Priority Based Scheduling:** -->
<h2 align="left" id="PriorityBasedScheduling"> 3. Priority Based Scheduling </h2>

**Priority Scheduling is a method of scheduling processes that is based on Priority.**

**Implementation:**

- Click on the **“Scheduling Algorithm”** button from the main window.
- Now click on the **“Priority Based Scheduling”** button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of **Arrival Time, Processes and Burst Time.**
- The output of this will show the **Completion Time, Turnaround Time, Wait Time, and Average Wait Time. **
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the **CPUScheduling.py** file.

<!-- ### 4. **Round Robin:**  -->
<h2 align="left" id="RoundRobin"> 4. Round Robin </h2>

**Round Robin is the oldest, simplest scheduling algorithm, which is mostly used for multitasking.**

**Implementation:**

- Click on the **“Scheduling Algorithm”** button from the main window.
- Now click on the **“Round Robin Scheduling”** button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some **pros and cons** written.
- Below all these, information there will be program, which has run using the random input of **Arrival Time, Processes and Burst Time.**
- The output of this will show the** Completion Time, Turnaround Time, Wait Time, and Average Wait Time. **
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the **CPUScheduling.py** file.

<!-- ### 5. **Lottery Scheduling:** -->
<h2 align="left" id="LotteryScheduling"> 5. Lottery Scheduling </h2>

**It is a type of process scheduling, somewhat different from other Scheduling. It can be pre-emptive or non- pre-emptive.**

**Implementation:**

- Click on the **“Scheduling Algorithm”** button from the main window.
- Now click on the **“Lottery Scheduling”** button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of **Arrival Time, Processes and Burst Time.**
- The output of this will show the** Completion Time, Turnaround Time, Wait Time, and Average Wait Time. **
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the **CPUScheduling.py** file.

<!-- ### 6. **Multi-Level Queue:** -->
<h2 align="left" id="MultiLevelQueue"> 6. Multi-Level Queue </h2>

**A Multi-Level Queue scheduling algorithm partitions the ready queue into several separate queues.**

**Implementation:**

- Click on the **“Scheduling Algorithm”** button from the main window.
- Now click on the **“Multi-Level Queue Scheduling”** button from the new window opened.
- It will open up a new window in which first there will be the definition of it.
- After that, there are some pros and cons written.
- Below all these, information there will be program, which has run using the random input of **Arrival Time of CPU-Bound, Processes of CPU-Bound, Burst Time of CPU-Bound, Arrival Time of I/O Bound, Processes of I/O Bound, and Burst Time of I/O Bound.**
- The output of this will show the** Completion Time, Turnaround Time, Wait Time, and Average Wait Time of CPU-Bound processes and I/O Bound processes. **
- After that there will be two options, either you can run another program or quit from there only.
- The code for this is available in the CPUScheduling.py file.

<br /><br />

<img align="left" src="https://user-images.githubusercontent.com/65415371/124740290-8e048b80-df12-11eb-9c29-654c9cb4561b.png" width="50px" />

<h2 align="left" id="idabout"> About: </h2> <br>
<!-- ### About: -->

### Technologies used in the project:

- **Python, Tkinter GUI library for Python Interface**

### Code Editor:

- **Pycharm IDE, Repl.it**

<br /><br />

<img align="left" src="https://user-images.githubusercontent.com/65415371/124740340-9eb50180-df12-11eb-9295-e33ac2752c57.png" width="50px" />

<h2 align="left" id="TeamMembers"> Team Members: </h2> <br>
<!-- ### Team Members: -->

### Manav Dhami

### Mohammed Hamza Malik

### Priyam Seth

### Priyanshu Datta

### Pratham Jain
